#!/bin/busybox sh

# Load modules.
modules() {
    for m in "$@" ; do busybox modprobe "$m" >/dev/null 2>&1 ; done
}

# Load crypto modules.
ciphers() {
    ifs0="$IFS" ; IFS="-"
    for m in $1 ; do modules "${m#essiv:}" ; done
    IFS="$ifs0"
}

# Recovery shell.
recovery() {
    PS1='(recovery) \w \$ ' busybox sh
	### </dev/tty0 >/dev/tty0 2>/dev/tty0
}

# Decrypt the volume using current cipher/size/hash parameters.
decrypt() {
    cryptdev="`busybox findfs "$1" 2>/dev/null`"
    if [ "z$cryptdev" != "z" ] ; then
	vname="${cryptdev##*/}-decrypted"
	if ! [ -e /dev/mapper/control ] ; then
	    # create /dev/mapper/control:
	    lvm vgscan --mknodes >/dev/null 2>&1
	fi
	# Disable kernel messages on console:
	printk0="`busybox cat /proc/sys/kernel/printk`"
	echo 0 >/proc/sys/kernel/printk
	# Decrypt the crypto-volume:
	if cryptsetup isLuks "$cryptdev" ; then
	    # TODO: query necessary ciphers from LUKS header
	    ciphers "aes-xts-plain64"
	    cryptsetup luksOpen "$cryptdev" "$vname"
	else
	    # Plain volumes don't store information about the
	    # ciphers used, so we need the $crypt_csh hint:
	    ifs0="$IFS" ; IFS="/" ; read c s h <<EOF
$crypt_csh
EOF
	    IFS="$ifs0"
	    if [ "z$c" != "z" ] ; then C="--cipher=$c" ; fi
	    if [ "z$s" != "z" ] ; then S="--key-size=$s" ; fi
	    if [ "z$h" != "z" ] ; then H="--hash=$h" ; fi
	    ciphers "${c:-aes-cbc-essiv:sha265}"
	    echo cryptsetup $C $S $H create "$vname" "$cryptdev"
	    cryptsetup $C $S $H create "$vname" "$cryptdev"
	fi
	# Enable kernel messages back:
	busybox cat >/proc/sys/kernel/printk <<EOF
$printk0
EOF
	# Activate logical volumes in the decrypted volume:
	lvm vgchange -aly >/dev/null 2>&1
    fi
}

# Mount a filesystem mentioned in fstab file in read-only mode.
#   USAGE: mount_fstab_ro /path/to/fstab /orig/mnt /new/mnt
#   example: mount_fstab_ro /mnt/root/etc/fstab /usr /mnt/root/usr
mount_fstab_ro() {
    for f in "$1" "$3" ; do
	if ! [ -e "$f" ] ; then
	    echo "$f doesn't exist" >&2
	    return 1
	fi
    done
    if ! [ -d "$3" ] ; then
	echo "$3 is not a directory" >&2
	return 1
    fi
    mnt=""
    while read dev mnt typ opts dump pass rest ; do
	if [ "z$mnt" = "z$2" ] ; then break ; fi
    done <"$1"
    if [ "z$mnt" = "z$2" ] ; then
	ropts="ro"
	oa=""
	oe=""
	os=""
	od=""
	ifs0="$IFS" ; IFS=","
	for o in $opts ; do
	    case "$o" in
		ro|rw|auto|noauto|nouser) o="";;
		group|owner)
		    os=",nosuid"
		    od=",nodev"
		    o=""
		    ;;
		user|users)
		    oe=",noexec"
		    os=",nosuid"
		    od=",nodev"
		    o=""
		    ;;
		defaults)
		    oa=",async"
		    oe=",exec"
		    os=",suid"
		    od=",dev"
		    o=""
		    ;;
		async)   oa=",async";   o="";;
		sync)    oa=",sync";    o="";;
		exec)    oe=",exec";    o="";;
		noexec)  oe=",noexec";  o="";;
		suid)    os=",suid";    o="";;
		nosuid)  os=",nosuid";  o="";;
		dev)     od=",dev";     o="";;
		nodev)   od=",nodev";   o="";;
	    esac
	    case "$o" in ?) ropts="$ropts,$o";; esac
	done
	ropts="$ropts$oa$oe$os$od"
	IFS="$ifs0"
	echo busybox mount -t "$typ" -o "$ropts" "$dev" "$3"
	busybox mount -t "$typ" -o "$ropts" "$dev" "$3"
    else
	echo "$2 fs not found in $1" >&2
	return 1
    fi
}

# Add /bin and /sbin to PATH:
path0="$PATH"
for p in /bin /sbin ; do
    case "$PATH" in
	*:$p:*|$p:*|*:$p) ;;
	?*) PATH="$p:$PATH" ;;
	*) PATH="$p" ;;
    esac
done
if [ "z$PATH" != "z$path0" ] ; then
    export PATH
fi

# Don't mount /dev if CONFIG_DEVTMPFS_MOUNT=y:
if ! busybox mountpoint -q /dev ; then
    busybox mount -t devtmpfs none /dev
fi
# Mount /proc and /sys:
busybox mount -t proc none /proc
busybox mount -t sysfs none /sys

# We need support for scsi/ata/usb/lvm/crypt block devices
# (TODO: detect/load ATA modules besides ata_piix):
modules xhci-hcd xhci-pci ehci-hcd ehci-pci ohci-hcd ohci-pci \
    uhci-hcd ata_piix sd_mod dm-crypt usb-storage uas
# We need keyboard support (i8042/atkbd/usb/hid) for reading
# dm-crypt passphrase:
modules libps2 serio atkbd i8042 hid hid-generic hidp usbhid

# Parse kernel commandline to find root volume ID or device
# and to find out which volumes to decrypt:
for a in `cat /proc/cmdline` ; do
    case "$a" in
	recovery) recovery=1;;
	root=?*) root="${a#root=}";;
	crypt_csh=*) crypt_csh="${a#crypt_csh=}";;
	crypt_root=?*) decrypt "${a#crypt_root=}";;
	rd.luks.uuid=?*) decrypt "UUID=${a#rd.luks.uuid=}";;
    esac
done

# Search for root volume and mount it:
rootdev="`busybox findfs "$root" 2>/dev/null`"

# Start recovery shell if root volume can not be found or mounted, or
# recovery is explicitly requested:
modules ext3 ; # TODO: detect filesystem on rootdev
if [ "z$rootdev" = "z" ] \
|| ! busybox mount -o ro "$rootdev" /mnt/root \
|| [ "z$recovery" = "z1" ] ; then
    recovery
fi

# Mount /usr filesystem (needed for udev?):
if [ -e /mnt/root/etc/fstab ] && [ -d /mnt/root/usr ] \
&& ! [ -e /mnt/root/usr/bin/md5sum ] \
&& grep '/usr.*must.*mount.*by.*initr' \
/mnt/root/lib/rc/sh/init.sh >/dev/null 2>&1 ; then
    mount_fstab_ro /mnt/root/etc/fstab /usr /mnt/root/usr
fi

# Unmount /sys, /proc, /dev and switch to new root:
busybox umount /sys
busybox umount /proc
busybox umount /dev
cd /mnt/root
exec busybox switch_root /mnt/root /sbin/init

# vi:filetype=sh sw=4 noet ts=8 tw=71:
